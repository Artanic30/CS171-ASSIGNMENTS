<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>Assignment2</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { border:initial none initial; white-space: pre !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
svg[id^="mermaidChart"] { line-height: 1em; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

html {
    font-size: 16px;
}

body {
    font-family: "Open Sans","Clear Sans","Helvetica Neue",Helvetica,Arial,sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;

}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}
#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    padding-bottom: .3em;
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
   padding-bottom: .3em;
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}
h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table tr td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    table,
    pre {
        page-break-inside: avoid;
    }
    pre {
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}


</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><h1>
	<a name="cs171-1-assignment3" class="md-header-anchor"></a><span style="box-sizing: border-box">CS171-1 Assignment2: Rendering mesh 
	with texture and normal mapping</span></h1><h2><a name="introduction" class="md-header-anchor"></a><strong><span>Introduction</span></strong></h2><p><span>
	<span style="box-sizing: border-box">In this assignment, you are required to texture a mesh object with Phong lighting and  perform normal mapping to change the surface details.  To realize these functionalities, you will need to (and you have to) use <i style="box-sizing: border-box">vertex shader</i> and <i style="box-sizing: border-box">fragment shader</i> in your program.</span></p><p>
	<span style="box-sizing: border-box">In the following, we will give you the specifics about what you need to finish, as well as some related guidelines in order to assist your programming in this assignment.</span></p><hr /><h2><a name="note" class="md-header-anchor"></a><strong><span>Note</span></strong></h2><p><strong><span>Before doing the assignment, please read the materials on OpenGL programming at </span><a href='https://learnopengl.com/Getting-started/OpenGL'><span>LearnOpenGL</span></a><span>. In this site you will learn how to build shaders, how to control your camera in shader and how to achieve texturing. You will also learn what is normal mapping and how to do <a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">normal mapping</a>. Please also study what is <a href="https://www.photoneray.com/opengl-vao-vbo/">VAO and VBO</a>.</span></strong></p><hr /><h2><a name="programming-requirements" class="md-header-anchor"></a><strong><span>Programming Requirements</span></strong></h2><ul><li><strong><span>[must]</span></strong><span> You are required to render a 3D object with Phong lighting model and Phong shading using OpenGL shaders and draw the model we give you in an OBJ file format.</span></li><li><strong><span>[must]</span></strong><span> You are required to texture the surface of the model with OpenGL shaders.</span></li><li><strong><span>[must]</span></strong><span> You are required to enable normal mapping for the model inside the OpenGL shaders.</span></li></ul><hr /><h2><a name="demonstration-requirements" class="md-header-anchor"></a><strong><span>Demonstration Requirements</span></strong></h2><p><strong><span>In addition to programming, you will also need to submit a demonstration video</span></strong><span>. </span></p><p><span>Things must be included in the demonstration video:</span></p><ul><li><span>Explain how you render 3D objects with Phong lighting model and Phong shading in shaders and show related code fragments and demonstrate the result.</span></li><li><span>Explain how you do texturing, show related code fragments and demonstrate the result.</span></li><li><span>Explain how you add normal map to the model, show related code fragments and demonstrate the result.</span></li></ul><p><u><span>Additional Notification</span></u><span>:</span></p><ul><li><span>You should present your result with your voice included.</span></li><li><span>You should </span><strong><span>only</span></strong><span> use Mandarin or English in your video.</span></li><li><span>Your should </span><strong><u><span>try your best</span></u></strong><span> to present your ideas clearly.</span></li><li><span>If you do not follow the above requirements, your score will be deduced by 10% of the entire assignment score.</span></li></ul><hr /><h2><a name="submission" class="md-header-anchor"></a><strong><span>Submission</span></strong></h2><p><span>You are required to submit following things through GitHub as shown in the tutorial video:</span></p><ul><li><span>project scripts and an executable program</span></li><li><span>a PDF-formatted report which describes what you have done</span></li><li><span>demonstration video which explains your implementation</span></li></ul><p><span>Submission deadline: <font color="#CC0000">22:00, April 9, 2020</font></span></p><hr /><h2><a name="grading-rules" class="md-header-anchor"></a><strong><span>Grading rules</span></strong></h2><ul><li><strong><span>NO CHEATING!</span></strong><span> If found, your score for the assignment is zero. You are required to work </span><strong><span>INDEPENDENTLY</span></strong><span>. We fully understand that implementations could be similar somewhere, but they cannot be identical. To avoid being evaluated inappropriately, please show your understanding of your codes in your submitted video.</span></li><li><span>Late submission of your assignment will subject to score deduction. </span></li></ul><hr /><h2><a name="skeleton-project-report-template" class="md-header-anchor"></a><span>Skeleton Project/ Report Template</span></h2><p><span>The skeleton program and report template will be provided once you accept the assignment link of GitHub classroom which we will publish in piazza. If you accept the assignment through the link properly, a repository which contains the skeleton project and report template will be created under your GitHub account. Please follow the template to prepare your report.</span></p><p><span>You should complete your assignment submission to your repository through GitHub before the deadline.</span></p><hr /><h2><a name="tutorial-video" class="md-header-anchor"></a><span>Tutorial Video</span></h2><p><span>In the tutorial video, we will describe the following topics:</span></p><ul><li><span>Interpretation of assignment requirements</span></li><li><span>Introduction on vertex shader and fragment shader</span></li><li><span>Introduction on texture mapping</span></li><li>Introduction on<span> how to add normal map</span></li></ul><p><span>Please have a check. Hope it can help you complete this assignment.</span></p><hr /><h2><a name="implementation-guide" class="md-header-anchor"></a><span>Implementation Guidance</span></h2><hr /><h3><a name="1build-shaders" class="md-header-anchor"></a><strong><span>1.Building Shaders</span></strong></h3><p><span>In the tutorial video, we will explain how to use <i>vertex shader</i> and <i>fragment shader</i> to render objects. Here is a </span><strong>b<span>rief</span></strong><span> introduction of these shaders.</span><i><strong style="font-weight: 400"><span>Please</span></strong><span><b> </b>read the materials on OpenGL programming at </span><a href='https://learnopengl.com/Getting-started/Shaders'><span>LearnOpenGL</span></a></i><span>.</span></p><p><span>Shaders are written in the C-like language.<a href="https://learnopengl.com/Getting-started/Shaders">GLSL</a>. GLSL is tailored for use in OpenGL and contains useful features specifically targeting vector and matrix manipulations.</span></p><h4><a name="structure" class="md-header-anchor"></a><span>Structure</span></h4><p><span>A shader typically has the following structure:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL" style="break-inside: unset;">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">#version version_number</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">in</span> <span class="cm-word">type</span> <span class="cm-word">in_variable_name</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">in</span> <span class="cm-word">type</span> <span class="cm-word">in_variable_name</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">out</span> <span class="cm-word">type</span> <span class="cm-word">out_variable_name</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">uniform</span> <span class="cm-word">type</span> <span class="cm-word">uniform_name</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">void</span> <span class="cm-word">main</span><span class="cm-bracket">()</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">{</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;<span class="cm-comment">// process input(s) and do some weird graphics stuff</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;<span class="cm-bracket">...</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;<span class="cm-comment">// output processed stuff to output variable</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;<span class="cm-word">out_variable_name</span> <span class="cm-operator">=</span> <span class="cm-word">weird_stuff_we_processed</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">}</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 336px;"></div><div class="CodeMirror-gutters" style="display: none; height: 336px;"></div></div></div></pre><h4><a name="data-tpyes" class="md-header-anchor"></a><span>Data Types</span></h4><p><span>GLSL has, like any other programming language, data types for specifying what kind of variable we want to work with. GLSL has most of the built-in types we know from languages like C: int, float, double, uint and bool. GLSL also features two container types that we&#39;ll be using a lot, namely vectors and matrices. </span></p><h5><a name="vectors" class="md-header-anchor"></a><span>Vectors</span></h5><p><span>The vector datatype allows for some interesting and flexible component selection called swizzling. Swizzling allows us to use syntax like this:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">vec2</span> <span class="cm-word">someVec</span><span class="cm-bracket">;</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">vec4</span> <span class="cm-word">differentVec</span> <span class="cm-operator">=</span> <span class="cm-word">someVec</span><span class="cm-bracket">.</span><span class="cm-word">xyxx</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">vec3</span> <span class="cm-word">anotherVec</span> <span class="cm-operator">=</span> <span class="cm-word">differentVec</span><span class="cm-bracket">.</span><span class="cm-word">zyw</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">vec4</span> <span class="cm-word">otherVec</span> <span class="cm-operator">=</span> <span class="cm-word">someVec</span><span class="cm-bracket">.</span><span class="cm-word">xxxx</span> <span class="cm-operator">+</span> <span class="cm-word">anotherVec</span><span class="cm-bracket">.</span><span class="cm-word">yxzy</span><span class="cm-bracket">;</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 90px;"></div><div class="CodeMirror-gutters" style="display: none; height: 90px;"></div></div></div></pre><h5><a name="matrices" class="md-header-anchor"></a><span>Matrices</span></h5><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">mat2</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">mat3</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">mat2x3</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">mat3x4</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 90px;"></div><div class="CodeMirror-gutters" style="display: none; height: 90px;"></div></div></div></pre><h5><a name="sampler" class="md-header-anchor"></a><span>Sampler</span></h5><p><span>GLSL has a built-in data-type for texture objects called a sampler that takes as a postfix the texture type we want e.g. sampler1D, sampler3D or in our case sampler2D. We can then add a texture to the fragment shader by simply declaring a uniform sampler2D that we later assign our texture to.</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">#version 330 </span><span class="cm-word">core</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">...</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">uniform</span> <span class="cm-keyword">sampler2D</span> <span class="cm-word">texture1</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">uniform</span> <span class="cm-keyword">sampler2D</span> <span class="cm-word">texture2</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">void</span> <span class="cm-word">main</span><span class="cm-bracket">()</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">{</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">FragColor</span> <span class="cm-operator">=</span> <span class="cm-builtin">mix</span><span class="cm-bracket">(</span><span class="cm-word">texture</span><span class="cm-bracket">(</span><span class="cm-word">texture1</span><span class="cm-bracket">,</span> <span class="cm-word">TexCoord</span><span class="cm-bracket">),</span> <span class="cm-word">texture</span><span class="cm-bracket">(</span><span class="cm-word">texture2</span><span class="cm-bracket">,</span> <span class="cm-word">TexCoord</span><span class="cm-bracket">),</span> <span class="cm-number">0.2</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">}</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 224px;"></div><div class="CodeMirror-gutters" style="display: none; height: 224px;"></div></div></div></pre><h5><a name="structure-n884" class="md-header-anchor"></a><span>Structure</span></h5><p><span>Like structure in C language.</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">struct</span> <span class="cm-word">PointLight</span> <span class="cm-bracket">{</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">vec3</span> <span class="cm-word">position</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">float</span> <span class="cm-word">constant</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">float</span> <span class="cm-word">linear</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">float</span> <span class="cm-word">quadratic</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">vec3</span> <span class="cm-word">ambient</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">vec3</span> <span class="cm-word">diffuse</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">vec3</span> <span class="cm-word">specular</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">};</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 202px;"></div><div class="CodeMirror-gutters" style="display: none; height: 202px;"></div></div></div></pre><h4><a name="ins-and-outs" class="md-header-anchor"></a><span>Ins and outs</span></h4><p><span>Shaders are small programs on their own, but they are part of a whole and for that reason we want to have inputs and outputs on the individual shaders so that we can move stuff around. GLSL defines the '<b>in</b>' and '<b>out</b>' keywords specifically for that purpose. Each shader can specify inputs and outputs using those keywords and wherever an output variable matches with an input variable of the next shader stage they&#39;re passed along. The vertex and fragment shader differ a bit though.</span></p><p><span>The vertex shader should receive some form of input; otherwise it would be pretty ineffective. The vertex shader differs in its input, in that it receives its input straightforwardly from the vertex data. To define how the vertex data is organized, we specify the input variables with location metadata, so that we can configure the vertex attributes on the CPU. We&#39;ve seen this in the previous tutorial as layout (location = 0). The vertex shader thus requires an extra layout specification for its inputs, so we can link it with the vertex data.</span></p><p><span>The other exception is that the fragment shader requires a vec4 color output variable, since the fragment shader needs to generate a final output color. If you fail to specify an output color in your fragment shader, the color buffer output for those fragments will be undefined (which usually means that OpenGL will render them either black or white).</span></p><p><span>So if we want to send data from one shader to the other, we&#39;d have to declare an output in the sending shader, and a similar input in the receiving shader. When the types and the names are equal on both sides, OpenGL will link those variables together, and then it is possible to send data between shaders (this is done when linking a program object). To show how this works in practice, we&#39;re going to alter the shaders from the previous tutorial to let the vertex shader decide the color for the fragment shader.</span></p><p><strong><span>Vertex shader</span></strong></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">#version 330 </span><span class="cm-word">core</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">layout</span> <span class="cm-bracket">(</span><span class="cm-word">location</span> <span class="cm-operator">=</span> <span class="cm-number">0</span><span class="cm-bracket">)</span> <span class="cm-keyword">in</span> <span class="cm-keyword">vec3</span> <span class="cm-word">aPos</span><span class="cm-bracket">;</span> <span class="cm-comment">// the position variable has attribute position 0</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">out</span> <span class="cm-keyword">vec4</span> <span class="cm-word">vertexColor</span><span class="cm-bracket">;</span> <span class="cm-comment">// specify a color output to the fragment shader</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">void</span> <span class="cm-word">main</span><span class="cm-bracket">()</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">{</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">gl_Position</span> <span class="cm-operator">=</span> <span class="cm-keyword">vec4</span><span class="cm-bracket">(</span><span class="cm-word">aPos</span><span class="cm-bracket">,</span> <span class="cm-number">1.0</span><span class="cm-bracket">);</span> <span class="cm-comment">// see how we directly give a vec3 to vec4's constructor</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">vertexColor</span> <span class="cm-operator">=</span> <span class="cm-keyword">vec4</span><span class="cm-bracket">(</span><span class="cm-number">0.5</span><span class="cm-bracket">,</span> <span class="cm-number">0.0</span><span class="cm-bracket">,</span> <span class="cm-number">0.0</span><span class="cm-bracket">,</span> <span class="cm-number">1.0</span><span class="cm-bracket">);</span> <span class="cm-comment">// set the output variable to a dark-red color</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">}</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 269px;"></div><div class="CodeMirror-gutters" style="display: none; height: 269px;"></div></div></div></pre><p><strong><span>Fragment shader</span></strong></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">#version 330 </span><span class="cm-word">core</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">out</span> <span class="cm-keyword">vec4</span> <span class="cm-word">FragColor</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">in</span> <span class="cm-keyword">vec4</span> <span class="cm-word">vertexColor</span><span class="cm-bracket">;</span> <span class="cm-comment">// the input variable from the vertex shader (same name and same type) &nbsp;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">void</span> <span class="cm-word">main</span><span class="cm-bracket">()</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">{</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">FragColor</span> <span class="cm-operator">=</span> <span class="cm-word">vertexColor</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">}</span> </span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 224px;"></div><div class="CodeMirror-gutters" style="display: none; height: 224px;"></div></div></div></pre><h4><a name="uniforms" class="md-header-anchor"></a><span>Uniforms</span></h4><p><span>Uniforms are another way to pass data from our application on the CPU to the shaders on the GPU. Uniforms are however slightly different compared to vertex attributes. First of all, uniforms are global. Global means that a uniform variable is unique per shader program object, and can be accessed from any shader at any stage in the shader program. Second, whatever you set the uniform values to, uniforms will keep their values until they&#39;re either reset or updated during the whole shader execution process.</span></p><p><span>To declare a uniform in GLSL, we simply add the uniform keyword to a shader with a type and a name. From that point on, we can use the newly declared uniform in the shader. Let&#39;s see if this time we can set the color of the triangle via a uniform:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">#version 330 </span><span class="cm-word">core</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">out</span> <span class="cm-keyword">vec4</span> <span class="cm-word">FragColor</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">uniform</span> <span class="cm-keyword">vec4</span> <span class="cm-word">ourColor</span><span class="cm-bracket">;</span> <span class="cm-comment">// we set this variable in the OpenGL code.</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">void</span> <span class="cm-word">main</span><span class="cm-bracket">()</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">{</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">FragColor</span> <span class="cm-operator">=</span> <span class="cm-word">ourColor</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">}</span> &nbsp; </span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 202px;"></div><div class="CodeMirror-gutters" style="display: none; height: 202px;"></div></div></div></pre><p><span>We declared a uniform vec4 ourColor in the fragment shader and set the fragment&#39;s output color to the content of this uniform value. Since uniforms are global variables, we can define them in any shader stage,&nbsp; so there is no need to go through the vertex shader again to get something to the fragment shader. We&#39;re not using this uniform in the vertex shader, so we do not need to define it there.</span>
<span>The uniform is currently empty, and we haven&#39;t added any data to the uniform yet, so let&#39;s try that. We first need to find the index/location of the uniform attribute in our shader. Once we have the index/location of the uniform, we can update its values. Instead of passing a single color to the fragment shader, let&#39;s spice things up by gradually changing color over time:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">float</span> <span class="cm-word">timeValue</span> <span class="cm-operator">=</span> <span class="cm-word">glfwGetTime</span><span class="cm-bracket">();</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">float</span> <span class="cm-word">greenValue</span> <span class="cm-operator">=</span> <span class="cm-bracket">(</span><span class="cm-builtin">sin</span><span class="cm-bracket">(</span><span class="cm-word">timeValue</span><span class="cm-bracket">)</span> <span class="cm-operator">/</span> <span class="cm-number">2.0f</span><span class="cm-bracket">)</span> <span class="cm-operator">+</span> <span class="cm-number">0.5f</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">int</span> <span class="cm-word">vertexColorLocation</span> <span class="cm-operator">=</span> <span class="cm-word">glGetUniformLocation</span><span class="cm-bracket">(</span><span class="cm-word">shaderProgram</span><span class="cm-bracket">,</span> <span class="cm-string">"ourColor"</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">glUseProgram</span><span class="cm-bracket">(</span><span class="cm-word">shaderProgram</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">glUniform4f</span><span class="cm-bracket">(</span><span class="cm-word">vertexColorLocation</span><span class="cm-bracket">,</span> <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> <span class="cm-word">greenValue</span><span class="cm-bracket">,</span> <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> <span class="cm-number">1.0f</span><span class="cm-bracket">);</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 112px;"></div><div class="CodeMirror-gutters" style="display: none; height: 112px;"></div></div></div></pre><p><span>First, we retrieve the running time in seconds via glfwGetTime(). Then we vary the color in the range of [0.0, 1.0] by using the 'sin' function and store the result in greenValue.</span></p><p><span>Then we query for the location of the ourColor uniform using glGetUniformLocation. We supply the shader program and the name of the uniform (that we want to retrieve the location from) to the query function. If glGetUniformLocation returns -1, it could not find the location. Lastly, we can set the uniform value using the glUniform4f function. Note that finding the uniform location does not require you to use the shader program first, but updating a uniform does require you to first use the program (by calling glUseProgram), because it sets the uniform on the currently active shader program.</span></p><p><span>Now that we know how to set the values of uniform variables, we can use them for rendering. If we want the color to gradually change, we want to update this uniform every frame; otherwise the triangle would maintain a single solid color if we only set it once. So we calculate the greenValue and update the uniform each render iteration:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL" style="break-inside: unset;">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">while</span><span class="cm-bracket">(</span><span class="cm-operator">!</span><span class="cm-word">glfwWindowShouldClose</span><span class="cm-bracket">(</span><span class="cm-word">window</span><span class="cm-bracket">))</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">{</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// input</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">processInput</span><span class="cm-bracket">(</span><span class="cm-word">window</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// render</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// clear the colorbuffer</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">glClearColor</span><span class="cm-bracket">(</span><span class="cm-number">0.2f</span><span class="cm-bracket">,</span> <span class="cm-number">0.3f</span><span class="cm-bracket">,</span> <span class="cm-number">0.3f</span><span class="cm-bracket">,</span> <span class="cm-number">1.0f</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">glClear</span><span class="cm-bracket">(</span><span class="cm-word">GL_COLOR_BUFFER_BIT</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// be sure to activate the shader</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">glUseProgram</span><span class="cm-bracket">(</span><span class="cm-word">shaderProgram</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// update the uniform color</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">float</span> <span class="cm-word">timeValue</span> <span class="cm-operator">=</span> <span class="cm-word">glfwGetTime</span><span class="cm-bracket">();</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">float</span> <span class="cm-word">greenValue</span> <span class="cm-operator">=</span> <span class="cm-builtin">sin</span><span class="cm-bracket">(</span><span class="cm-word">timeValue</span><span class="cm-bracket">)</span> <span class="cm-operator">/</span> <span class="cm-number">2.0f</span> <span class="cm-operator">+</span> <span class="cm-number">0.5f</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">int</span> <span class="cm-word">vertexColorLocation</span> <span class="cm-operator">=</span> <span class="cm-word">glGetUniformLocation</span><span class="cm-bracket">(</span><span class="cm-word">shaderProgram</span><span class="cm-bracket">,</span> <span class="cm-string">"ourColor"</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">glUniform4f</span><span class="cm-bracket">(</span><span class="cm-word">vertexColorLocation</span><span class="cm-bracket">,</span> <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> <span class="cm-word">greenValue</span><span class="cm-bracket">,</span> <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> <span class="cm-number">1.0f</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// now render the triangle</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">glBindVertexArray</span><span class="cm-bracket">(</span><span class="cm-word">VAO</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">glDrawArrays</span><span class="cm-bracket">(</span><span class="cm-word">GL_TRIANGLES</span><span class="cm-bracket">,</span> <span class="cm-number">0</span><span class="cm-bracket">,</span> <span class="cm-number">3</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// swap buffers and poll IO events</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">glfwSwapBuffers</span><span class="cm-bracket">(</span><span class="cm-word">window</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">glfwPollEvents</span><span class="cm-bracket">();</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">}</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 605px;"></div><div class="CodeMirror-gutters" style="display: none; height: 605px;"></div></div></div></pre><p><span>The code is a relatively straightforward adaptation of the previous code. This time, we update a uniform value each frame before drawing the triangle. If you update the uniform correctly, you should see that the color of your triangle gradually changes from green to black and back to green.</span></p><p><span>We have seen in the previous tutorial how we can fill a VBO, configure vertex attribute pointers and store it all in a VAO. This time, we also want to add color data to the vertex data. We're going to add color data as 3 floats to the vertex array. We assign a red, green and blue color to each of the corners of our triangle respectively:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">float</span> <span class="cm-word">vertices</span><span class="cm-bracket">[]</span> <span class="cm-operator">=</span> <span class="cm-bracket">{</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// positions &nbsp; &nbsp; &nbsp; &nbsp; // colors</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-number">0.5f</span><span class="cm-bracket">,</span> <span class="cm-operator">-</span><span class="cm-number">0.5f</span><span class="cm-bracket">,</span> <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> &nbsp;<span class="cm-number">1.0f</span><span class="cm-bracket">,</span> <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> &nbsp; <span class="cm-comment">// bottom right</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-operator">-</span><span class="cm-number">0.5f</span><span class="cm-bracket">,</span> <span class="cm-operator">-</span><span class="cm-number">0.5f</span><span class="cm-bracket">,</span> <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> &nbsp;<span class="cm-number">0.0f</span><span class="cm-bracket">,</span> <span class="cm-number">1.0f</span><span class="cm-bracket">,</span> <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> &nbsp; <span class="cm-comment">// bottom left</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> &nbsp;<span class="cm-number">0.5f</span><span class="cm-bracket">,</span> <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> &nbsp;<span class="cm-number">0.0f</span><span class="cm-bracket">,</span> <span class="cm-number">0.0f</span><span class="cm-bracket">,</span> <span class="cm-number">1.0f</span> &nbsp; &nbsp;<span class="cm-comment">// top </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">};</span> &nbsp; &nbsp;</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 134px;"></div><div class="CodeMirror-gutters" style="display: none; height: 134px;"></div></div></div></pre><p><span>Since we now have more data to send to the vertex shader, it is necessary to adjust the vertex shader to also receive our color value as a vertex attribute input. Note that we set the location of the aColor attribute to 1 with the layout specifier:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">#version 330 </span><span class="cm-word">core</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">layout</span> <span class="cm-bracket">(</span><span class="cm-word">location</span> <span class="cm-operator">=</span> <span class="cm-number">0</span><span class="cm-bracket">)</span> <span class="cm-keyword">in</span> <span class="cm-keyword">vec3</span> <span class="cm-word">aPos</span><span class="cm-bracket">;</span> &nbsp; <span class="cm-comment">// the position variable has attribute position 0</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">layout</span> <span class="cm-bracket">(</span><span class="cm-word">location</span> <span class="cm-operator">=</span> <span class="cm-number">1</span><span class="cm-bracket">)</span> <span class="cm-keyword">in</span> <span class="cm-keyword">vec3</span> <span class="cm-word">aColor</span><span class="cm-bracket">;</span> <span class="cm-comment">// the color variable has attribute position 1</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">out</span> <span class="cm-keyword">vec3</span> <span class="cm-word">ourColor</span><span class="cm-bracket">;</span> <span class="cm-comment">// output a color to the fragment shader</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">void</span> <span class="cm-word">main</span><span class="cm-bracket">()</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">{</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">gl_Position</span> <span class="cm-operator">=</span> <span class="cm-keyword">vec4</span><span class="cm-bracket">(</span><span class="cm-word">aPos</span><span class="cm-bracket">,</span> <span class="cm-number">1.0</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">ourColor</span> <span class="cm-operator">=</span> <span class="cm-word">aColor</span><span class="cm-bracket">;</span> <span class="cm-comment">// set ourColor to the input color we got from the vertex data</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">}</span> &nbsp; &nbsp; &nbsp; </span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 246px;"></div><div class="CodeMirror-gutters" style="display: none; height: 246px;"></div></div></div></pre><p><span>Since we no longer use a uniform for the fragment/pixel&#39;s color, but now use the ourColor output variable, we&#39;ll have to change the fragment shader as well:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">#version 330 </span><span class="cm-word">core</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">out</span> <span class="cm-keyword">vec4</span> <span class="cm-word">FragColor</span><span class="cm-bracket">;</span> &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">in</span> <span class="cm-keyword">vec3</span> <span class="cm-word">ourColor</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">void</span> <span class="cm-word">main</span><span class="cm-bracket">()</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">{</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">FragColor</span> <span class="cm-operator">=</span> <span class="cm-keyword">vec4</span><span class="cm-bracket">(</span><span class="cm-word">ourColor</span><span class="cm-bracket">,</span> <span class="cm-number">1.0</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">}</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 179px;"></div><div class="CodeMirror-gutters" style="display: none; height: 179px;"></div></div></div></pre><p><span>Knowing the current layout, we can update the vertex format with glVertexAttribPointer:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">// position attribute</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">glVertexAttribPointer</span><span class="cm-bracket">(</span><span class="cm-number">0</span><span class="cm-bracket">,</span> <span class="cm-number">3</span><span class="cm-bracket">,</span> <span class="cm-word">GL_FLOAT</span><span class="cm-bracket">,</span> <span class="cm-word">GL_FALSE</span><span class="cm-bracket">,</span> <span class="cm-number">6</span> <span class="cm-operator">*</span> <span class="cm-word">sizeof</span><span class="cm-bracket">(</span><span class="cm-keyword">float</span><span class="cm-bracket">),</span> <span class="cm-bracket">(</span><span class="cm-keyword">void</span><span class="cm-operator">*</span><span class="cm-bracket">)</span><span class="cm-number">0</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">glEnableVertexAttribArray</span><span class="cm-bracket">(</span><span class="cm-number">0</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">// color attribute</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">glVertexAttribPointer</span><span class="cm-bracket">(</span><span class="cm-number">1</span><span class="cm-bracket">,</span> <span class="cm-number">3</span><span class="cm-bracket">,</span> <span class="cm-word">GL_FLOAT</span><span class="cm-bracket">,</span> <span class="cm-word">GL_FALSE</span><span class="cm-bracket">,</span> <span class="cm-number">6</span> <span class="cm-operator">*</span> <span class="cm-word">sizeof</span><span class="cm-bracket">(</span><span class="cm-keyword">float</span><span class="cm-bracket">),</span> <span class="cm-bracket">(</span><span class="cm-keyword">void</span><span class="cm-operator">*</span><span class="cm-bracket">)(</span><span class="cm-number">3</span><span class="cm-operator">*</span> <span class="cm-word">sizeof</span><span class="cm-bracket">(</span><span class="cm-keyword">float</span><span class="cm-bracket">)));</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">glEnableVertexAttribArray</span><span class="cm-bracket">(</span><span class="cm-number">1</span><span class="cm-bracket">);</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 157px;"></div><div class="CodeMirror-gutters" style="display: none; height: 157px;"></div></div></div></pre><p><span>The first few arguments of glVertexAttribPointer are relatively straightforward. This time we are configuring the vertex attribute on attribute location 1. The color values have a size of 3 floats and we do not normalize the values.</span></p><p><span>Since we now have two vertex attributes, we have to re-calculate the stride value. To get the next attribute value (e.g. the next x-component of the position vector) in the data array, we have to move 6 floats to the right, three for the position values and three for the color values. This gives us a stride value of 6 times the size of a float in bytes (= 24 bytes).</span>
<span>Also, this time we have to specify an offset. For each vertex, the position vertex attribute is located first, so we declare an offset of 0. The color attribute starts after the position data, so the offset is 3 * sizeof(float) in bytes (= 12 bytes).</span></p><p><span>Running the application should result in a colorful triangle.</span>
<img src="shaders3.png" referrerpolicy="no-referrer" alt="shaders3"></p><hr /><h3><a name="2textures" class="md-header-anchor"></a><strong><span>2.Textures</span></strong></h3><p><span>Here is a </span><strong>b<span>rief</span></strong><span> introduction of textures in OpenGL.</span>
<i><strong style="font-weight: 400"><span>Please</span></strong><span> read the materials on OpenGL programming at </span><a href='https://learnopengl.com/Getting-started/Textures'><span>LearnOpenGL</span></a></i><span>.</span></p><p><span>In order to map a texture to the triangle, we need to tell each vertex of the triangle which part of the texture it corresponds to. Each vertex should thus have a texture coordinate associated with them that specifies what part of the texture image to sample from. Fragment interpolation then does the rest for the other fragments.</span></p><p><span>Texture coordinates range from 0 to 1 in the x and y axis (remember that we use 2D texture images). Retrieving the texture color using texture coordinates is called sampling. Texture coordinates start from (0,0) for the lower left corner of a texture image to (1,1) at the upper right corner of a texture image. The following image shows how we map texture coordinates to the triangle:</span>
<img src="tex_coords.png" referrerpolicy="no-referrer" alt="texcoord"></p><p><span>We specify 3 texture coordinate points for the triangle. We want the bottom-left side of the triangle to correspond to the bottom-left side of the texture, so we use the (0,0) texture coordinate for the triangle&#39;s bottom-left vertex. The same applies to the bottom-right side with a (1,0) texture coordinate. The top of the triangle should correspond to the top-center of the texture image, so we take (0.5,1.0) as its texture coordinate. We only have to pass 3 texture coordinates to the vertex shader, which then passes those to the fragment shader that neatly interpolates all the texture coordinates for each fragment.</span></p><h4><a name="texture-wrapping" class="md-header-anchor"></a><span>Texture Wrapping</span></h4><p><span>Texture coordinates usually range from (0,0) to (1,1), but what happens if we specify coordinates outside this range? The default behavior of OpenGL is to repeat the texture images (we basically ignore the integer part of the floating point texture coordinate), but there are more options OpenGL offers:</span></p><blockquote><p><span>GL_REPEAT: The default behavior for textures. It repeats the texture image.</span>
<span><br>GL_MIRRORED_REPEAT: Same as GL_REPEAT, but mirrors the image.</span>
<span><br>GL_CLAMP_TO_EDGE: Clamps the coordinates between 0 and 1. The result is that coordinates outside the desired range are clamped to the boundary of the range, resulting in a stretched edge pattern.</span>
<span><br>GL_CLAMP_TO_BORDER: Coordinates outside the range are now given a user-specified border color.</span></p></blockquote><h4><a name="texture-filtering" class="md-header-anchor"></a><span>Texture Filtering</span></h4><p><span>Texture coordinates do not depend on resolution, but can be any floating point value; thus OpenGL has to figure out which texture pixel (also known as a texel ) to map the texture coordinate to. This becomes especially important if you have a very large object and a low resolution texture. You probably guessed by now that OpenGL has options for this texture filtering as well. There are several options available but for now we&#39;ll discuss the most important options: GL_NEAREST and GL_LINEAR.</span>
<span>GL_NEAREST (also known as nearest neighbor or point filtering) is the default texture filtering method of OpenGL. When setting to GL_NEAREST, OpenGL selects the texel whose center is closest to the texture coordinate.</span>
<span>GL_LINEAR (also known as bilinear filtering) takes an interpolated value from the texture coordinate&#39;s neighboring texels, approximating a color between the texels. The smaller the distance from the texture coordinate to a texel&#39;s center, the more that texel&#39;s color contributes to the sampled color. </span></p><p><span>Texture filtering can be set for magnifying and minifying operations (when scaling up and down), so you could, for example, use nearest neighbor filtering when textures are scaled down and linear filtering for scaling up textures. We thus have to specify the filtering method for both options via glTexParameter</span><span>*</span><span>. The code should look similar to setting the wrapping method:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">glTexParameteri</span><span class="cm-bracket">(</span><span class="cm-word">GL_TEXTURE_2D</span><span class="cm-bracket">,</span> <span class="cm-word">GL_TEXTURE_MIN_FILTER</span><span class="cm-bracket">,</span> <span class="cm-word">GL_NEAREST</span><span class="cm-bracket">);</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">glTexParameteri</span><span class="cm-bracket">(</span><span class="cm-word">GL_TEXTURE_2D</span><span class="cm-bracket">,</span> <span class="cm-word">GL_TEXTURE_MAG_FILTER</span><span class="cm-bracket">,</span> <span class="cm-word">GL_LINEAR</span><span class="cm-bracket">);</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 45px;"></div><div class="CodeMirror-gutters" style="display: none; height: 45px;"></div></div></div></pre><h4><a name="mipmaps" class="md-header-anchor"></a><span>Mipmaps</span></h4><p><span>Imagine we have a large room with thousands of objects, each with an attached texture. There will be objects far away that have the same high resolution texture attached as the objects close to the viewer. Since the objects are far away and probably only produce a few fragments, OpenGL has difficulties retrieving the right color value for its fragment from the high resolution texture, since it has to pick a texture color for a fragment that spans a large part of the texture. This will produce visible artifacts on small objects, not to mention the waste of memory bandwidth using high resolution textures on small objects.</span></p><p><span>To solve this issue, OpenGL uses a concept called mipmaps that is basically a collection of texture images where each subsequent texture is twice as small compared to the previous one. The idea behind mipmaps is easy to understand: based on the distance from the viewer, OpenGL will use different mipmap textures that best suits the distance to the object. Because the object is far away, the smaller resolution will not be noticeable to the user. OpenGL is then able to sample the correct texels, and there&#39;s less cache memory involved when sampling that part of the mipmaps.</span></p><p><span>Creating a collection of mipmapped textures for each texture image is cumbersome to do manually, but luckily OpenGL is able to do all the work for us with a single call to glGenerateMipmaps after we&#39;ve created a texture. Later in the texture tutorial, you&#39;ll see the use of this function.</span></p><p><span>When using between mipmaps during rendering, OpenGL might show some artifacts like sharp edges visible between the two mipmap layers. Just like normal texture filtering, it is also possible to filter between mipmap levels using NEAREST and LINEAR filtering for interpolating texels. To specify the filtering method for mipmaps, we can replace the original filtering methods with one of the following four options:</span></p><blockquote><p><span>GL_NEAREST_MIPMAP_NEAREST: takes the nearest mipmap to match the pixel size and uses nearest neighbor interpolation for texture sampling.</span>
<span><br>GL_LINEAR_MIPMAP_NEAREST: takes the nearest mipmap level and samples that level using linear interpolation.</span>
<span><br>GL_NEAREST_MIPMAP_LINEAR: linearly interpolates between the two mipmaps that most closely match the size of a pixel and samples the interpolated level via nearest neighbor interpolation.</span>
<span><br>GL_LINEAR_MIPMAP_LINEAR: linearly interpolates between the two closest mipmaps and samples the interpolated level via linear interpolation.</span></p></blockquote><h4><a name="loading-and-creating-textures" class="md-header-anchor"></a><span>Loading and creating textures</span></h4><p><span>The first thing we need to do to actually use textures is to load them into our application. Texture images can be stored in dozens of file formats, each with their own structure and ordering of data, so how do we get those images in our application? One solution would be to choose a file format we&#39;d like to use, say .PNG and write our own image loader to convert the image format into a large array of bytes. While it&#39;s not very hard to write your own image loader, it&#39;s still cumbersome and what if you want to support more file formats? You&#39;d then have to write an image loader for each format you want to support.</span></p><p><span>Another solution, and probably a good one, is to use an image-loading library that supports several popular formats and does all the hard work for us. A library like stb_image.h.</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="C++">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c++"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define STB_IMAGE_IMPLEMENTATION</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#include "stb_image.h"</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">int</span> <span class="cm-variable">width</span>, <span class="cm-variable">height</span>, <span class="cm-variable">nrChannels</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">unsigned</span> <span class="cm-variable-3">char</span> <span class="cm-variable-3">*</span><span class="cm-variable">data</span> <span class="cm-operator">=</span> <span class="cm-variable">stbi_load</span>(<span class="cm-string">"container.jpg"</span>, <span class="cm-operator">&amp;</span><span class="cm-variable">width</span>, <span class="cm-operator">&amp;</span><span class="cm-variable">height</span>, <span class="cm-operator">&amp;</span><span class="cm-variable">nrChannels</span>, <span class="cm-number">0</span>);</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 112px;"></div><div class="CodeMirror-gutters" style="display: none; height: 112px;"></div></div></div></pre><h4><a name="generating-a-texture" class="md-header-anchor"></a><span>Generating a texture</span></h4><p><span>Like any of the previous objects in OpenGL, textures are referenced with an ID; let&#39;s create one:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="c++">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c++"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">unsigned</span> <span class="cm-variable-3">int</span> <span class="cm-variable">texture</span>;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glGenTextures</span>(<span class="cm-number">1</span>, <span class="cm-operator">&amp;</span><span class="cm-variable">texture</span>); &nbsp;</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 45px;"></div><div class="CodeMirror-gutters" style="display: none; height: 45px;"></div></div></div></pre><p><span>The glGenTextures function first takes as input how many textures we want to generate and store them in an unsigned int array given as its second argument (in our case just a single unsigned int). Just like other objects, we need to bind it so that any subsequent texture commands will configure the currently bound texture:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="c++">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c++"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glBindTexture</span>(<span class="cm-variable">GL_TEXTURE_2D</span>, <span class="cm-variable">texture</span>); &nbsp;</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 22px;"></div><div class="CodeMirror-gutters" style="display: none; height: 22px;"></div></div></div></pre><p><span>Now that the texture is bound, we can start generating a texture using the previously loaded image data. Textures are generated with glTexImage2D:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="c++">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c++"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glTexImage2D</span>(<span class="cm-variable">GL_TEXTURE_2D</span>, <span class="cm-number">0</span>, <span class="cm-variable">GL_RGB</span>, <span class="cm-variable">width</span>, <span class="cm-variable">height</span>, <span class="cm-number">0</span>, <span class="cm-variable">GL_RGB</span>, <span class="cm-variable">GL_UNSIGNED_BYTE</span>, <span class="cm-variable">data</span>);</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glGenerateMipmap</span>(<span class="cm-variable">GL_TEXTURE_2D</span>);</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 45px;"></div><div class="CodeMirror-gutters" style="display: none; height: 45px;"></div></div></div></pre><p><span>This is a large function with quite a few parameters so we&#39;ll walk through them step-by-step:</span></p><blockquote><p><span>The first argument specifies the texture target; setting this to GL_TEXTURE_2D means this operation will generate a texture on the currently bound texture object at the same target (so any textures bound to targets GL_TEXTURE_1D or GL_TEXTURE_3D will not be affected).</span>
<span>The second argument specifies the mipmap level for which we want to create a texture for if you want to set each mipmap level manually, but we&#39;ll leave it at the base level which is 0.</span>
<span>The third argument tells OpenGL in what kind of format we want to store the texture. Our image has only RGB values so we&#39;ll store the texture with RGB values as well.</span>
<span>The 4th and 5th argument sets the width and height of the resulting texture. We stored those earlier when loading the image so we&#39;ll use the corresponding variables.</span>
<span>The next argument should always be 0 (some legacy stuff).</span>
<span>The 7th and 8th argument specify the format and data type of the source image. We loaded the image with RGB values and stored them as chars (bytes) so we&#39;ll pass in the corresponding values.</span>
<span>The last argument is the actual image data.</span></p></blockquote><p><span>Once glTexImage2D is called, the currently bound texture object now has the texture image attached to it. However, currently it only has the base-level of the texture image loaded and if we want to use mipmaps we have to specify all the different images manually (by continually incrementing the second argument) or, we could call glGenerateMipmap after generating the texture. This will automatically generate all the required mipmaps for the currently bound texture.</span></p><p><span>After we&#39;re done generating the texture and its corresponding mipmaps, it is good practice to free the image memory:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="c++">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c++"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">stbi_image_free</span>(<span class="cm-variable">data</span>);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 22px;"></div><div class="CodeMirror-gutters" style="display: none; height: 22px;"></div></div></div></pre><p><span>The whole process of generating a texture thus looks something like this:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="c++" style="break-inside: unset;">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c++"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">unsigned</span> <span class="cm-variable-3">int</span> <span class="cm-variable">texture</span>;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glGenTextures</span>(<span class="cm-number">1</span>, <span class="cm-operator">&amp;</span><span class="cm-variable">texture</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glBindTexture</span>(<span class="cm-variable">GL_TEXTURE_2D</span>, <span class="cm-variable">texture</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">// set the texture wrapping/filtering options (on the currently bound texture object)</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-variable">glTexParameteri</span>(<span class="cm-variable">GL_TEXTURE_2D</span>, <span class="cm-variable">GL_TEXTURE_WRAP_S</span>, <span class="cm-variable">GL_REPEAT</span>);<span class="cm-tab" role="presentation" cm-text="	">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glTexParameteri</span>(<span class="cm-variable">GL_TEXTURE_2D</span>, <span class="cm-variable">GL_TEXTURE_WRAP_T</span>, <span class="cm-variable">GL_REPEAT</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glTexParameteri</span>(<span class="cm-variable">GL_TEXTURE_2D</span>, <span class="cm-variable">GL_TEXTURE_MIN_FILTER</span>, <span class="cm-variable">GL_LINEAR</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glTexParameteri</span>(<span class="cm-variable">GL_TEXTURE_2D</span>, <span class="cm-variable">GL_TEXTURE_MAG_FILTER</span>, <span class="cm-variable">GL_LINEAR</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">// load and generate the texture</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">int</span> <span class="cm-variable">width</span>, <span class="cm-variable">height</span>, <span class="cm-variable">nrChannels</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">unsigned</span> <span class="cm-variable-3">char</span> <span class="cm-variable-3">*</span><span class="cm-variable">data</span> <span class="cm-operator">=</span> <span class="cm-variable">stbi_load</span>(<span class="cm-string">"container.jpg"</span>, <span class="cm-operator">&amp;</span><span class="cm-variable">width</span>, <span class="cm-operator">&amp;</span><span class="cm-variable">height</span>, <span class="cm-operator">&amp;</span><span class="cm-variable">nrChannels</span>, <span class="cm-number">0</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">if</span> (<span class="cm-variable">data</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">glTexImage2D</span>(<span class="cm-variable">GL_TEXTURE_2D</span>, <span class="cm-number">0</span>, <span class="cm-variable">GL_RGB</span>, <span class="cm-variable">width</span>, <span class="cm-variable">height</span>, <span class="cm-number">0</span>, <span class="cm-variable">GL_RGB</span>, <span class="cm-variable">GL_UNSIGNED_BYTE</span>, <span class="cm-variable">data</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">glGenerateMipmap</span>(<span class="cm-variable">GL_TEXTURE_2D</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">else</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">std::cout</span> <span class="cm-operator">&lt;&lt;</span> <span class="cm-string">"Failed to load texture"</span> <span class="cm-operator">&lt;&lt;</span> <span class="cm-variable">std::endl</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">stbi_image_free</span>(<span class="cm-variable">data</span>);</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 493px;"></div><div class="CodeMirror-gutters" style="display: none; height: 493px;"></div></div></div></pre><h4><a name="applying-textures" class="md-header-anchor"></a><span>Applying textures</span></h4><p><span>For the upcoming sections, we will use a rectangle shape drawn with glDrawElements. We need to inform OpenGL how to sample the texture so we&#39;ll have to update the vertex data with the texture coordinates:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="c++">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c++"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">float</span> <span class="cm-variable">vertices</span>[] <span class="cm-operator">=</span> {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// positions &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // colors &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // texture coords</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-number">0.5f</span>, &nbsp;<span class="cm-number">0.5f</span>, <span class="cm-number">0.0f</span>, &nbsp; <span class="cm-number">1.0f</span>, <span class="cm-number">0.0f</span>, <span class="cm-number">0.0f</span>, &nbsp; <span class="cm-number">1.0f</span>, <span class="cm-number">1.0f</span>, &nbsp; <span class="cm-comment">// top right</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; <span class="cm-number">0.5f</span>, <span class="cm-operator">-</span><span class="cm-number">0.5f</span>, <span class="cm-number">0.0f</span>, &nbsp; <span class="cm-number">0.0f</span>, <span class="cm-number">1.0f</span>, <span class="cm-number">0.0f</span>, &nbsp; <span class="cm-number">1.0f</span>, <span class="cm-number">0.0f</span>, &nbsp; <span class="cm-comment">// bottom right</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-operator">-</span><span class="cm-number">0.5f</span>, <span class="cm-operator">-</span><span class="cm-number">0.5f</span>, <span class="cm-number">0.0f</span>, &nbsp; <span class="cm-number">0.0f</span>, <span class="cm-number">0.0f</span>, <span class="cm-number">1.0f</span>, &nbsp; <span class="cm-number">0.0f</span>, <span class="cm-number">0.0f</span>, &nbsp; <span class="cm-comment">// bottom left</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-operator">-</span><span class="cm-number">0.5f</span>, &nbsp;<span class="cm-number">0.5f</span>, <span class="cm-number">0.0f</span>, &nbsp; <span class="cm-number">1.0f</span>, <span class="cm-number">1.0f</span>, <span class="cm-number">0.0f</span>, &nbsp; <span class="cm-number">0.0f</span>, <span class="cm-number">1.0f</span> &nbsp; &nbsp;<span class="cm-comment">// top left </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">};</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glVertexAttribPointer</span>(<span class="cm-number">2</span>, <span class="cm-number">2</span>, <span class="cm-variable">GL_FLOAT</span>, <span class="cm-variable">GL_FALSE</span>, <span class="cm-number">8</span> <span class="cm-operator">*</span> <span class="cm-keyword">sizeof</span>(<span class="cm-variable-3">float</span>), (<span class="cm-variable-3">void*</span>)(<span class="cm-number">6</span> <span class="cm-operator">*</span> <span class="cm-keyword">sizeof</span>(<span class="cm-variable-3">float</span>)));</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glEnableVertexAttribArray</span>(<span class="cm-number">2</span>);</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 246px;"></div><div class="CodeMirror-gutters" style="display: none; height: 246px;"></div></div></div></pre><p><span>Note that we have to adjust the stride parameter of the previous two vertex attributes to 8 * sizeof(float) as well.</span></p><p><span>Next we need to alter the vertex shader to accept the texture coordinates as a vertex attribute and then forward the coordinates to the fragment shader:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL" style="break-inside: unset;">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">#version 330 </span><span class="cm-word">core</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">layout</span> <span class="cm-bracket">(</span><span class="cm-word">location</span> <span class="cm-operator">=</span> <span class="cm-number">0</span><span class="cm-bracket">)</span> <span class="cm-keyword">in</span> <span class="cm-keyword">vec3</span> <span class="cm-word">aPos</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">layout</span> <span class="cm-bracket">(</span><span class="cm-word">location</span> <span class="cm-operator">=</span> <span class="cm-number">1</span><span class="cm-bracket">)</span> <span class="cm-keyword">in</span> <span class="cm-keyword">vec3</span> <span class="cm-word">aColor</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-word">layout</span> <span class="cm-bracket">(</span><span class="cm-word">location</span> <span class="cm-operator">=</span> <span class="cm-number">2</span><span class="cm-bracket">)</span> <span class="cm-keyword">in</span> <span class="cm-keyword">vec2</span> <span class="cm-word">aTexCoord</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">out</span> <span class="cm-keyword">vec3</span> <span class="cm-word">ourColor</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">out</span> <span class="cm-keyword">vec2</span> <span class="cm-word">TexCoord</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">void</span> <span class="cm-word">main</span><span class="cm-bracket">()</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">{</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">gl_Position</span> <span class="cm-operator">=</span> <span class="cm-keyword">vec4</span><span class="cm-bracket">(</span><span class="cm-word">aPos</span><span class="cm-bracket">,</span> <span class="cm-number">1.0</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">ourColor</span> <span class="cm-operator">=</span> <span class="cm-word">aColor</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">TexCoord</span> <span class="cm-operator">=</span> <span class="cm-word">aTexCoord</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">}</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 314px;"></div><div class="CodeMirror-gutters" style="display: none; height: 314px;"></div></div></div></pre><p><span>The fragment shader should then accept the TexCoord output variable as an input variable.</span></p><p><span>The fragment shader should also have access to the texture object, but how do we pass the texture object to the fragment shader? GLSL has a built-in data-type for texture objects called a sampler that takes as a postfix the texture type we want e.g. sampler1D, sampler3D or in our case sampler2D. We can then add a texture to the fragment shader by simply declaring a uniform sampler2D that we later assign our texture to.</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="GLSL">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="glsl"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">#version 330 </span><span class="cm-word">core</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">out</span> <span class="cm-keyword">vec4</span> <span class="cm-word">FragColor</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">in</span> <span class="cm-keyword">vec3</span> <span class="cm-word">ourColor</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">in</span> <span class="cm-keyword">vec2</span> <span class="cm-word">TexCoord</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">uniform</span> <span class="cm-keyword">sampler2D</span> <span class="cm-word">ourTexture</span><span class="cm-bracket">;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">void</span> <span class="cm-word">main</span><span class="cm-bracket">()</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">{</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-word">FragColor</span> <span class="cm-operator">=</span> <span class="cm-word">texture</span><span class="cm-bracket">(</span><span class="cm-word">ourTexture</span><span class="cm-bracket">,</span> <span class="cm-word">TexCoord</span><span class="cm-bracket">);</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-bracket">}</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 269px;"></div><div class="CodeMirror-gutters" style="display: none; height: 269px;"></div></div></div></pre><p><span>To sample the color of a texture, we use GLSL&#39;s built-in texture function that takes as its first argument a texture sampler and as its second argument the corresponding texture coordinates. The texture function then samples the corresponding color value using the texture parameters we set earlier. The output of this fragment shader is then the (filtered) color of the texture at the (interpolated) texture coordinate.</span></p><p><span>All that&#39;s left to do now is to bind the texture before calling glDrawElements, and it will then automatically assign the texture to the fragment shader&#39;s sampler:</span></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="c++">&nbsp;<div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c++"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glBindTexture</span>(<span class="cm-variable">GL_TEXTURE_2D</span>, <span class="cm-variable">texture</span>);</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glBindVertexArray</span>(<span class="cm-variable">VAO</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">glDrawElements</span>(<span class="cm-variable">GL_TRIANGLES</span>, <span class="cm-number">6</span>, <span class="cm-variable">GL_UNSIGNED_INT</span>, <span class="cm-number">0</span>);</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 67px;"></div><div class="CodeMirror-gutters" style="display: none; height: 67px;"></div></div></div></pre><p><span>If you did everything right you should see the following image:</span>
<img src="textures2.png" referrerpolicy="no-referrer" alt="textures2"></p><p>&nbsp;</p><hr /><p><strong><span>Normal mapping</span></strong><span> is a technique used for faking the lighting of bumps and dents – an implementation of bump mapping. It is used to add details without using more polygons. You can learn more about it in </span><a href='https://learnopengl.com/Advanced-Lighting/Normal-Mapping'><span>Normal mapping</span></a></p><hr /><h3><a name="3tangent-space-for-normal-mapping" class="md-header-anchor"></a><strong><span>3.Tangent space (for Normal Mapping)</span></strong></h3><p><span>Normal vectors in a normal map are expressed in tangent space where normals always point roughly in the positive z direction. Tangent space is a space that&#39;s local to the surface of a triangle: the normals are relative to the local reference frame of the individual triangles. Think of it as the local space of the normal map&#39;s vectors; they&#39;re all defined pointing in the positive z direction regardless of the final transformed direction. Using a specific matrix we can then transform normal vectors from this local tangent space to world or view coordinates, orienting them along the final mapped surface&#39;s direction.</span></p><p><span>Let&#39;s say we have the incorrect normal mapped surface from the previous section looking in the positive y direction. The normal map is defined in tangent space, so one way to solve the problem is to calculate a matrix to transform normals from tangent space to a different space such that they&#39;re aligned with the surface&#39;s normal direction: the normal vectors are then all pointing roughly in the positive y direction. The great thing about tangent space is that we can calculate such a matrix for any type of surface so that we can properly align the tangent space&#39;s z direction to the surface&#39;s normal direction.</span></p><p><span>Such a matrix is called a TBN matrix where the letters depict a tangent, bitangent and normal vector. These are the vectors we need to construct this matrix. To construct such a change-of-basis matrix that transforms a tangent-space vector to a different coordinate space we need three perpendicular vectors that are aligned along the surface of a normal map: an up, right and forward vector; similar to what we did in the camera tutorial.</span></p><p><span>We already know the up vector which is the surface&#39;s normal vector. The right and forward vector are the tangent and bitangent vector respectively. The following image of a surface shows all three vectors on a surface:</span>
<img src="normal_mapping_tbn_vectors.png" referrerpolicy="no-referrer" alt="normal_mapping_tbn_vectors">
<span>Calculating the tangent and bitangent vectors is not as straightforward as the normal vector. We can see from the image that the direction of the normal map&#39;s tangent and bitangent vector align with the direction in which we define a surface&#39;s texture coordinates. We&#39;ll use this fact to calculate tangent and bitangent vectors for each surface. Retrieving them does require a bit of math; take a look at the following image:</span>
<img src="normal_mapping_surface_edges.png" referrerpolicy="no-referrer" alt="normal_mapping_surface_edges"></p><p><img src="1.png" referrerpolicy="no-referrer" alt="1"></p><hr /><h3><a name="4generate-normal-map-from-images" class="md-header-anchor"></a><strong><span>4.Generate normal map from images</span></strong></h3><p><span>This part is about how to generate a normal map from an image. You do not need to do that in this assignment, but you need to know how to do it.</span></p><ol start='' ><li><p><span>The first step is to convert the image into a grayscale image.</span></p><blockquote><p><span>gray = (r+b+g)/3</span></p></blockquote></li><li><p><span>Use gradient to calculate preliminary normal map.</span>
<span>Here we use a higher grayscale image to obtain a preliminary normal map. Since normal is a three-dimensional vector (x, y, z), we use the following method to calculate the normal vector at the point (i, k). We use the Sobel algorithm to calculate the gradient in the horizontal and numerical directions, that is:</span></p><blockquote><p><span>dx = G(i-1,k-1) + 2 * G(i,k-1) + G(i+1,k-1) - G(i-1,k+1) - 2 * G(i,k+1) + G(i+1,k+1)</span>
<span>dy = G(i-1,k-1) + 2 * G(i-1,k) + G(i-1,k+1) - G(i+1,k-1) - 2 * G(i+1,k) - G(i+1,k+1)</span></p></blockquote></li></ol><p><span>Now the normal value at point (i, k) is:</span></p><blockquote><p><span>x = dy</span>
<span>y = -dx</span>
<span>z = strength</span>
<span>Normal(i,k) = (x,y,z)</span></p></blockquote><ol start='3' ><li><span>Recalculate a reduced intermediate normal map  for the downscaled image. Although a preliminary normal map can be obtained through the above steps, the normal map obtained in this way is not smooth enough. Therefore, we use a method commonly used in PS to correct the normal.</span></li></ol><p><span>We downsample the original image, which is to reduce the input grayscale Image. For example, shrink to 50%. Then perform the processing in step 2 on this reduced grayscale Image to find a reduced normal map.</span></p><ol start='4' ><li><span>Combine two normal maps to get the final normal map.</span>
<span>Enlarge the reduced normal map back to its original size, and then average it with the preliminary normal map to get the final normal map.</span></li></ol><p>&nbsp;</p><p>&nbsp;</p></div>
</body>
</html>